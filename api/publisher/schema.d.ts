/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v1/blobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Store a blob on Walrus.
         * @description Store a (potentially deletable) blob on Walrus for 1 or more epochs. The associated on-Sui
         *     object can be sent to a specified Sui address.
         */
        put: operations["put_blob"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Format: binary */
        Binary: string;
        /** @description Sui object for a blob. */
        Blob: {
            /** @description The blob ID. */
            blobId: components["schemas"]["BlobId"];
            certifiedEpoch?: null | components["schemas"]["u32"];
            /** @description Marks the blob as deletable. */
            deletable: boolean;
            /** @description The encoding coding type used for the blob. */
            encodingType: components["schemas"]["EncodingType"];
            id: components["schemas"]["ObjectID"];
            /** @description The epoch in which the blob has been registered. */
            registeredEpoch: components["schemas"]["u32"];
            /**
             * Format: int64
             * @description The (unencoded) size of the blob.
             */
            size: number;
            /** @description The [`StorageResource`] used to store the blob. */
            storage: components["schemas"]["StorageResource"];
        };
        /**
         * Format: byte
         * @description The ID of a blob.
         */
        BlobId: string;
        /** @description Result when attempting to store a blob. */
        BlobStoreResult: {
            /** @description The blob already exists within Walrus, was certified, and is stored for at least the
             *     intended duration. */
            alreadyCertified: components["schemas"]["EventOrObjectId"] & {
                /** @description The blob ID. */
                blob_id: components["schemas"]["BlobId"];
                /**
                 * Format: int64
                 * @description The epoch until which the blob is stored (exclusive).
                 */
                end_epoch: number;
            };
        } | {
            /** @description The blob was newly created; this contains the newly created Sui object associated with the
             *     blob. */
            newlyCreated: {
                /** @description The Sui blob object that holds the newly created blob. */
                blobObject: components["schemas"]["Blob"];
                /**
                 * Format: int64
                 * @description The storage cost, excluding gas.
                 */
                cost: number;
                /** @description The operation that created the blob. */
                resource_operation: components["schemas"]["RegisterBlobOp"];
                shared_blobObject?: null | components["schemas"]["ObjectID"];
            };
        } | {
            /** @description The blob is known to Walrus but was marked as invalid.
             *
             *     This indicates a bug within the client, the storage nodes, or more than a third malicious
             *     storage nodes. */
            markedInvalid: {
                /** @description The blob ID. */
                blob_id: components["schemas"]["BlobId"];
                /** @description The event where the blob was marked as invalid. */
                event: components["schemas"]["EventID"];
            };
        } | {
            /** @description Operation failed. */
            error: {
                blob_id?: null | components["schemas"]["BlobId"];
                /** @description The error message. */
                error_msg: string;
            };
        };
        /**
         * @description Supported Walrus encoding types.
         * @enum {string}
         */
        EncodingType: "RedStuffRaptorQ" | "RS2";
        /**
         * Format: int32
         * @description Walrus epoch.
         */
        Epoch: number;
        /** @description Schema for the [`sui_types::event::EventID`] type. */
        EventID: {
            eventSeq: string;
            txDigest: number[];
        };
        /** @description Either an event ID or an object ID. */
        EventOrObjectId: {
            /** @description The variant representing an event ID. */
            event: components["schemas"]["EventID"];
        } | {
            /** @description The variant representing an object ID. */
            object: components["schemas"]["ObjectID"];
        };
        /**
         * Sui object ID
         * @description Sui object ID as a hexadecimal string
         */
        ObjectID: string;
        /** @description The operation performed on blob and storage resources to register a blob. */
        RegisterBlobOp: {
            /** @description The storage and blob resources are purchased from scratch. */
            registerFromScratch: {
                /**
                 * Format: int64
                 * @description The size of the encoded blob in bytes.
                 */
                encoded_length: number;
                /**
                 * Format: int32
                 * @description The number of epochs ahead for which the blob is registered.
                 */
                epochs_ahead: number;
            };
        } | {
            /** @description The storage is reused, but the blob was not registered. */
            reuseStorage: {
                /**
                 * Format: int64
                 * @description The size of the encoded blob in bytes.
                 */
                encoded_length: number;
            };
        } | {
            /** @description A registration was already present. */
            reuseRegistration: {
                /**
                 * Format: int64
                 * @description The size of the encoded blob in bytes.
                 */
                encoded_length: number;
            };
        } | {
            /** @description The blob was already certified, but its lifetime is too short. */
            reuseAndExtend: {
                /**
                 * Format: int64
                 * @description The size of the encoded blob in bytes.
                 */
                encoded_length: number;
                /**
                 * Format: int32
                 * @description The number of epochs extended wrt the original epoch end.
                 */
                epochs_extended: number;
            };
        } | {
            /** @description The blob was registered, but not certified, and its lifetime is shorter than
             *     the desired one. */
            reuseAndExtendNonCertified: {
                /**
                 * Format: int64
                 * @description The size of the encoded blob in bytes.
                 */
                encoded_length: number;
                /**
                 * Format: int32
                 * @description The number of epochs extended wrt the original epoch end.
                 */
                epochs_extended: number;
            };
        };
        /** @description A message returned from a failed API call.
         *
         *     Contains both human-readable and machine-readable details of the error,
         *     to assist in resolving the error. */
        Status: {
            error: {
                /**
                 * Format: int32
                 * @description HTTP status code associated with the error.
                 */
                code: number;
                /** @description General type of error, given as an UPPER_SNAKE_CASE string. */
                status: string;
            } & {
                /** @description Machine readable details of the error.
                 *
                 *     Always contains an [`ErrorInfo`], which provides a machine-readable
                 *     representation of the of the `message` field. */
                details: Record<string, never>[];
                /** @description A message describing the error in detail. */
                message: string;
            };
        };
        /** @description Sui object for storage resources. */
        StorageResource: {
            /** @description The end epoch of the resource (exclusive). */
            endEpoch: components["schemas"]["u32"];
            id: components["schemas"]["ObjectID"];
            /** @description The start epoch of the resource (inclusive). */
            startEpoch: components["schemas"]["u32"];
            /**
             * Format: int64
             * @description The total amount of reserved storage.
             */
            storageSize: number;
        };
        /**
         * Sui address
         * @description Sui address encoded as a hexadecimal string
         */
        SuiAddress: string;
        /** Format: int32 */
        u32: number;
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    put_blob: {
        parameters: {
            query?: {
                /** @description The encoding type to use for the blob. */
                encoding_type?: null | components["schemas"]["EncodingType"];
                /** @description The number of epochs, ahead of the current one, for which to store the blob.
                 *
                 *     The default is 1 epoch. */
                epochs?: components["schemas"]["u32"];
                /** @description If true, the publisher creates a deletable blob instead of a permanent one. */
                deletable?: boolean;
                /** @description If specified, the publisher will send the Blob object resulting from the store operation to
                 *     this Sui address. */
                send_object_to?: null | components["schemas"]["SuiAddress"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Binary data of the unencoded blob to be stored. */
        requestBody: {
            content: {
                "application/octet-stream": components["schemas"]["Binary"];
            };
        };
        responses: {
            /** @description The blob was stored successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BlobStoreResult"];
                };
            };
            /** @description The request is malformed */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The blob is too large */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description  The blob cannot be returned as has been blocked. */
            451: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"];
                };
            };
            /** @description An internal server error has occurred. Please report this error. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"];
                };
            };
            /** @description  The service failed to store the blob to sufficient Walrus storage nodes before a timeout, please retry the operation. */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"];
                };
            };
        };
    };
}
